used visual vm chekc memory graph
check latest version and may be some version causing issue 
check multithreading, or any native thread 
add jvm param ->  -XX:+UseContainerSupport -XX:+UseG1GC -XX:MaxRAMPercentage=50 -XX:InitialRAMPercentage=15 -Xss1m -XX:+UseStringDeduplication
check memory and cpu  -> req and limit 
check java object 




-This gives: InitialRAMPercentage
  ‚Ä¢	Initial heap ‚âà 15% of 8 GB ‚âà 1.2 GB
	‚Ä¢	Max heap ‚âà 50% of 8 GB ‚âà 4 GB
	‚Ä¢	JVM grows heap only if needed
	‚Ä¢	No dangerous startup spike

What is -XX:+UseContainerSupport?

In simple words:

It tells the JVM to respect the container‚Äôs CPU and memory limits instead of the host machine‚Äôs full resources.

Without this flag, the JVM may think it has access to:
	‚Ä¢	The entire node‚Äôs memory (e.g., 64 GB)
	‚Ä¢	The entire node‚Äôs CPU cores (e.g., 32 cores)

Even though your pod is limited to a much smaller slice (like 1.5 GB or 8 GB).


Explain JVM memory model (Heap, Metaspace, Stack).

	‚Ä¢	How does G1 GC work? When would you tune GC?
	‚Ä¢	Difference between OutOfMemoryError: Metaspace vs Heap.


	‚Ä¢	How do you debug a memory leak in production?
jmap -dump:live,format=b,file=heap.hprof <pid> ->‚ÄúBefore dumping, run a Full GC and include only objects that are still reachable (alive).‚Äù

1Ô∏è‚É£ Removes noise (MOST IMPORTANT)

Without -live:
	‚Ä¢	Heap dump contains:
	‚Ä¢	Dead objects
	‚Ä¢	Short-lived allocations
	‚Ä¢	Garbage waiting to be collected

With -live:
	‚Ä¢	Dump contains only objects preventing memory from being freed

How to debug Metaspace leaks?
Metaspace leaks are caused by ClassLoaders not being GC‚Äôd.
I monitor Metaspace growth, trace class loading/unloading, analyze ClassLoader references using MAT, 
identify why the loader is retained, 
fix the root cause, and validate class unloading instead of increasing Metaspace.‚Äù'
A Metaspace leak happens when classes keep getting loaded but never unloaded because t
heir ClassLoader is still referenced.

 Check heap dump ‚Üí multiple ClassLoaders?
‚úî Disable Spring DevTools in prod
‚úî Check redeploy / hot reload
‚úî Check dynamic proxy creation in loops
‚úî Deregister drivers & listeners
‚úî Restart app after fix (Metaspace leaks need restart)

üëâ Key difference:
	‚Ä¢	Heap leak ‚Üí objects not GC‚Äôd
	‚Ä¢	Metaspace leak ‚Üí classes not unloaded

1Ô∏è‚É£ Identify Metaspace symptoms

Common signs
	‚Ä¢	OutOfMemoryError: Metaspace
	‚Ä¢	Heap looks normal
	‚Ä¢	GC activity is normal
	‚Ä¢	Metaspace usage keeps increasing

Confirm via JVM stats
jstat -gcmetacapacity <pid> 5s
Look for:
	‚Ä¢	Increasing MC / MU
	‚Ä¢	No drop after Full GC

Enable Metaspace observability
-XX:+TraceClassLoading
-XX:+TraceClassUnloading
if you see:
	‚Ä¢	Lots of class loading
	‚Ä¢	Little or no class unloading

jmap -dump:live,file=heap.hprof <pid>
Analyze ClassLoader references, not objects.

6Ô∏è‚É£ Spring / Microservices specific leaks

Typical offenders
	‚Ä¢	CGLIB proxies created dynamically
	‚Ä¢	Reloadable contexts
	‚Ä¢	@Configuration classes reloaded
	‚Ä¢	Spring Boot fat-jar ClassLoader

Fixes
	‚Ä¢	Disable DevTools in prod -># disable in prod
         spring.devtools.restart.enabled=false
	‚Ä¢	Avoid runtime class generation
       Proxy.newProxyInstance(...)   // inside request flow
       or dynamic bytecode generation in loops.

         GOOD pattern
	     ‚Ä¢	Create proxies once at startup
	     ‚Ä¢	Reuse them
       	 ‚Ä¢	Use fixed proxies

   ‚Ä¢	Clean up on shutdown
        bad
           DriverManager.registerDriver(...)
        good 
           @PreDestroy
           public void cleanup() {
               DriverManager.deregisterDriver(driver);
            }
